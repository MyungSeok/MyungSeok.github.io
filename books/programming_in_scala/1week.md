# 1주차 (1 ~ 4 Chapter)

## Chapter 01 확장 가능한 언어

스칼라(Scala) 라는 이름은 확장 가능한 언어(Scalable) 라는 뜻이다.
이렇게 이름을 지은 이유는 스칼라를 사용자의 요구에 따라 자랄 수 있는 언어로 설계했기 때문이다.

> `scalable` 은 규모를 늘이고 줄이는게 자유롭다는 뜻이며, <br/>보통 규모가 늘어나거나 줄어들어도 성능이나 비용이 선형적으로 증가한다는 뜻이다.

스칼라는 객체지향 (Object Oriented) 과 함수형 (Functional) 프로그래밍 개념을 정적 타입 언어 (Statically Typed Language) 에 합쳐놓은 언어이다.

### 1.1  여러분의 마음에서 점점 자라나는 언어 (a language that grows on you)

```scala
var captial = Map("US" -> "Washington", "France" -> "Paris)
capital += ("Japan" -> "Tokyo")
println(capital("France"))
```

위와 같이 높은 수준의 간결하고, 불필요한 세미콜론이나 타입 지정으로 인해 지저분하지 않게 코드 작성이 가능하다.

이들의 공통적인 특징은 **연관맵**을 언어수준에서 지원한다는 점이다.

### 새로운 타입을 키워가기

스칼라는 스칼라를 사용하는 사람들이 확장하고 변경할 수 있도록 설계했다. (Growing a language)

```scala
def factorial(x: BigInt): BigInt = 
  if (x == 0)
    1
  else 
    x * factorial(x - 1)
```

`factorial(30)` 을 호출하면 다음과 같은 결과를 볼 수 있다.

```scala
265252859812191058636308480000000
```

반환 타입인 `BigInt` 는 마치 내장 타입인것 처럼 보이지만 **스칼라 표준 라이브러리에 들어있는 평범한 클래스**일 뿐이다.

예를 들어 Java 에서 지원하는 `BigInteger` 를 사용한다면 다음과 같이 표현될 것 이다.

```scala
import java.math.BigInteger

def factorial(x: BigInteger): BigInteger = 
  if (x == BigInteger.ZERO)
    BigInteger.ONE
  else
    x.multiply(factorial(x.subtract(BigInteger.ONE)))
```

위와 같은 코드는 내장타입이 그에 맞는 메서드나 기능을 제공해줘야 하기 때문에 다양한 환경에서 유연하게 적용하기 어려울 것이다.

가령 십진수, 복소수, 유리수, 신뢰구간, 다항식 등의 모든 기능을 하나의 언어에서 모든것을 제공하는 것은 확장성이 좋지 않다.<br/>
스칼라는 언어가 기본적으로 지원하는것 처럼 사용자가 쉽게 사용할 수 있는 라이브러리를 제공하는 방식으로 사용자가 필요한 방향으로 확장하고 고칠 수 있게 허용한다.

### 새로운 제어 구조 키워가기

스칼라의 확장성 원칙을 제어 구조에도 마찬가지로 적용된다.

이러한 확정성을 **액터 기반 동시선 프로그래밍 (Actor-based concurrent programming)** 스칼라 API 인 아카(Akka) 에서 볼 수 있다.

동시성 프로그래밍을 작성하는 일은 꽤 어려우며 자바의 스레드 모델은 **공유 메모리 (Shared Memory) 와 락 (Lock) 기반**으로 하며 코드를 보고 논리적으로 추론하기가 어렵다.<br/>코드에 숨어있는 경합 조건 (race condition) 이나 교착 상태 (deadlock) 이 없다고 확신하기는 어렵다.

안전한 대안은 얼랭 (Erlang) 프로그래밍에서 사용하는 **액터** 같은 메세지 전달 아키텍쳐이다.

다음 코드는 recipient 라는 **액터**에 메세지를 보내는 문장이다.

```scala
recipient ! msg
```

송신은 비동기적 (asynchronous) 이며 메세지를 보낸 액터는 수신가가 메세지를 수신할 때 까지 기다릴 필요 없이 즉시 다음 작업을 진행할 수 있다.

모든 액터는 우편함 (mailbox) 가 있으며 우편함에 도착한 메세지는 `receive` 블럭을 이용하여 처리한다.

```scala
def receive = {
  case Msg1 => ... // Msg1을 처리함
  case Msg2 => ... // Msg2를 처리함
}
```

주어진 여러 case 를 만족하는 메세지가 우편함에 없을 경우 액터는 동작을 멈추가 다음 메세지가 도착할 때 까지 기다린다.

다음은 체크섬 (checksum) 계산 서비스를 구현하는 아카 액터다.

```scala
class CheckSumActor extends Actor {
  var sum = 0
  
  def receive = {
    case Data(byte) => sum += byte
    case GetChecksum(requester) => 
      val checksum = ~(sum & 0xFF) + 1
      requester ! checksum
  }
}
```

위 코드는 `receive` 블럭을 정의한 후 <br/>
`Data` 메세지를 받으면 그 안에 들어있는 데이터 (byte) 에 sum 변수를 더한다.
`GetChecksum` 메세지를 받으면 sum 의 현재값을 이용하여 체크섬을 계산한 다음 요청한 `requester` 에게 `requester ! checksum` 이라는 송신 명령을 사용하여 결괏값을 전송한다.

이 코드에서 `receive` 나 메세지 송신 (!) 은 스칼라가 제공하는 내장 기능이 아니라 액터 라이브러리에서 제공하는 메서드에 불과하며, 스칼라 프로그래밍과는 별개의 정의된 메서드를 동작시키는 것이다.

액터 모델이 분산 컴퓨팅을 구현하는데 매우 적절한 도구이지만 이는 라이브러리임에도 불구하고 스칼라 언어와 하나인것처럼 보이며, 이는 마치 애초에 그 기능을 원래 언어가 지원하는것 처럼 느끼게 할 수 있다.

### 1.2 스칼라의 확장성이 가능한 이유

스칼라의 확장성에 가장 큰 영향을 끼치는 요인은 **객체 지향과 함수형 프로그래밍의 조합**이다.

스칼라에서는 함숫값도 객체이다.<br/>
앞에서 보여준 액터의 개념은 함수와 객체를 통합하지 않았다면 구현할 수 없었을 것이다.

### 스칼라는 객체지향적이다.

스칼라는 순수한 형태의 객체지향 언어이다.

모든 값이 객체이며, 모든 연산은 메서드 호출이다.<br/>
가령 `1 + 2` 라고 쓰면, 실제로는 `Int` 클래스가 정의한 `+` 라는 이름의 메서드를 호출하는 것이다.

스칼라의 트레이트 (trait) 를 이용하면 믹스인 (mixin) 조합을 통하여 클래스의 여러가지 측면을 각각 별도의 트레이트에 캡슐화 (encapsulate) 할 수 있다.

트레이트를 사용하면 다중 상속의 고전적 문제인 '다이아몬드 상속' 을 피할 수 있다.

> #### 다이아몬드 상속
> 동일한 클래스를 여러 경로를 통해 여러번 상속하는 경우<br/>
> [Java 에서는 다중 상속을 지원하지 않으며](https://siyoon210.tistory.com/125) C++ 같은 경우에도 안티패턴으로 사용을 지양한다.

### 스칼라는 함수형이다.

함수형 프로그래밍은 두가지 주요 아이디어에서 방향이 결정된다.

#### 1급 계층 (First Class) 이다.

함수형 언어에서의 함수는 정수나 문자열과 동일한 자격을 갖는 값이다.<br/>
이는 다음과 같은 특성을 갖는다.

* 함수를 다른 함수의 인자로 넘길수 있다.
* 함수 안에서 결과로 함수를 반환할 수 있다.
* 함수를 변수에 저장할 수 있다.
* 함수안에서 함수를 정의할 수 잇다.

#### 프로그램은 입력값을 출력값으로 변환해야 하며, 데이터를 그 자리에서 변경하지 말아야 한다는 점이다.

예를 들면 `s.replace(",", ":")` 은 새로운 문자열 객체가 생기며 기존 `s` 와는 다르다.<br/>
이는 변경 불가능 (immutable) 과 변경 가능 (mutable) 의 특성과도 유사한데 각 언어의 성격마다 다르다.<br/>
변경 불가능한 데이터 구조는 함수형 프로그램의 초석 중 하나이다.<br/>
스칼라의 경우 변경 불가능한 데이터 구조로써 리스트, 튜플, 맵, 집합을 제공한다.

또한 `replace` 와 같이 시스템에 다른 영향을 주지 않는 메서드를 **참조 투명 (referentially transparent) 하다** 한다.

함수형 언어는 변경 불가능한 데이터와 참조 투명한 메서드를 장려한다.

### 1.3 왜 스칼라인가?



