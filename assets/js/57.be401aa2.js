(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{330:function(t,a,e){"use strict";e.r(a);var s=e(1),r=Object(s.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"generic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#generic","aria-hidden":"true"}},[t._v("#")]),t._v(" Generic")]),t._v(" "),e("p",[t._v("하나 이상의 매개변수 타입 (Paramter Type) 을 선언하고 있는 클래스나 인터페이스를 제네릭 타입 이라 한다.")]),t._v(" "),e("p",[e("strong",[t._v("Syntax")])]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("타입 파라메터"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 리턴타입 메소드명 "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("매개변수"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* statement */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("strong",[t._v("타입의 이름")])]),t._v(" "),e("p",[t._v("아무 문자열이나 사용가능하지만 가독성을 위해 일반적으로 다음 규칙을 따른다.")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("키")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("설명")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("E")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("요소(Element)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("K")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("키(Key)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("N")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("숫자(Number)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("T")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("타입(Type)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("V")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("값(Value)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("S, U, V")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("두번째, 세번째, 네번째에 선언된 타입")])])])]),t._v(" "),e("h2",{attrs:{id:"parameterized-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parameterized-type","aria-hidden":"true"}},[t._v("#")]),t._v(" Parameterized Type")]),t._v(" "),e("p",[t._v("매개변수화 타입 (Parameterized Type) 은 다음 두가지로 나뉘어 진다.")]),t._v(" "),e("h3",{attrs:{id:"actual-type-parameter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#actual-type-parameter","aria-hidden":"true"}},[t._v("#")]),t._v(" Actual Type Parameter")]),t._v(" "),e("p",[t._v("실 타입 매개변수 (Actual Type Parameter) 는 "),e("code",[t._v("<>")]),t._v(" 안에 "),e("em",[e("strong",[t._v("실사용 타입 자체를 명시")])]),t._v(" 해주는 방식이다.")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h3",{attrs:{id:"formal-type-parameter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#formal-type-parameter","aria-hidden":"true"}},[t._v("#")]),t._v(" Formal Type Parameter")]),t._v(" "),e("p",[t._v("형식 타입 매개변수 (Formal Type Parameter) 타입 매개변수는 "),e("code",[t._v("<>")]),t._v(" 안에 "),e("em",[e("strong",[t._v("명시적 타입을 주는 방식")])]),t._v(" 이다.")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("제네릭은 타입 소거자 (Type Erasure) 에 의해 자신의 타입 요소 정보를 삭제한다.")]),t._v(" "),e("p",[t._v("때문에 아래와 같이 실 타입 매개변수 형태의 선언을 컴파일 과정에서 다음과 같이 변경한다.")]),t._v(" "),e("p",[e("strong",[t._v("Before")])]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[e("strong",[t._v("After")])]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),t._v(" list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("컴파일러는 컴파일 단계에서 "),e("code",[t._v("List Collection")]),t._v(" 에 "),e("code",[t._v("String")]),t._v(" 인스턴스만 저장되어야 한다는 것을 인지하며"),e("br"),t._v("\n또 그것을 보장하기 때문에 "),e("code",[t._v("ArrayList")]),t._v(" 로 변경하여도 Runtime 시에 동일한 동작을 보장한다.")]),t._v(" "),e("p",[t._v("이러한 방식을 다음 두가지로 나뉜다.")]),t._v(" "),e("p",[e("strong",[t._v("구체화 타입 (reifiable type)")])]),t._v(" "),e("ul",[e("li",[t._v("자신의 타입 정보를 런타임 시에 알고 지키게 하는것")]),t._v(" "),e("li",[t._v("런타임에 구체화 하는것")])]),t._v(" "),e("p",[e("strong",[t._v("비 구체화 타입 (non-reifiable type)")])]),t._v(" "),e("ul",[e("li",[t._v("타입 소거자에 의해 컴파일 타임에 타입정보가 사라지는 것")]),t._v(" "),e("li",[t._v("런타임에 구체화 하지 않는것")])]),t._v(" "),e("h2",{attrs:{id:"unbounded-wildcard-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unbounded-wildcard-type","aria-hidden":"true"}},[t._v("#")]),t._v(" Unbounded Wildcard Type")]),t._v(" "),e("p",[e("code",[t._v("List<?>")]),t._v(" 와 같은 타입을 언바운드 와일드카드 타입 (Unbounded Wildcard Type) 이라고 한다.")]),t._v(" "),e("blockquote",[e("p",[t._v("Unbounded : 무한한")])]),t._v(" "),e("p",[t._v("이 형태를 이용하는 유형은 다음과 같다.")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("Object")]),t._v(" 클래스에서 제공되는 기능을 사용하여 구현할 수 있는 메서드를 작성하는 경우")]),t._v(" "),e("li",[t._v("타입 파라메터에 의존적이지 않는 일반 클래스의 메서드를 사용하는 경우 ("),e("code",[t._v("List.clear")]),t._v(", "),e("code",[t._v("List.size")]),t._v(", "),e("code",[t._v("Class<?>")]),t._v(")")])]),t._v(" "),e("h2",{attrs:{id:"bounded-wildcard-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bounded-wildcard-type","aria-hidden":"true"}},[t._v("#")]),t._v(" Bounded Wildcard Type")]),t._v(" "),e("p",[t._v("바운드 와일드 카드 타입 (Bounded Wildcard Type) 은 "),e("code",[t._v("Collection")]),t._v(" 계열의 클래스들의 코드에 자주 사용되는 방식이다.")]),t._v(" "),e("h3",{attrs:{id:"무공변-invariant"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#무공변-invariant","aria-hidden":"true"}},[t._v("#")]),t._v(" 무공변 (Invariant)")]),t._v(" "),e("p",[t._v("오로지 자기 타입만 허용하는 것 "),e("code",[t._v("<T>")])]),t._v(" "),e("h3",{attrs:{id:"공변-covariant"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#공변-covariant","aria-hidden":"true"}},[t._v("#")]),t._v(" 공변 (Covariant)")]),t._v(" "),e("p",[t._v("구체적인 방향으로 타입 변환을 허용하는 것")]),t._v(" "),e("p",[t._v("자기 자신과 자식 객체만 허용 (리스코프 치환 법칙) "),e("code",[t._v("<? extends T>")])]),t._v(" "),e("h3",{attrs:{id:"반공변-contravariant"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#반공변-contravariant","aria-hidden":"true"}},[t._v("#")]),t._v(" 반공변 (Contravariant)")]),t._v(" "),e("p",[t._v("추상적인 방향으로의 타입 변환을 허용하는 것")]),t._v(" "),e("p",[t._v("자기 자신과 부모 객체만 허용 "),e("code",[t._v("<? super T>")])]),t._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("참고자료")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://onsil-thegreenhouse.github.io/programming/java/2018/02/17/java_tutorial_1-21/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://onsil-thegreenhouse.github.io/programming/java/2018/02/17/java_tutorial_1-21/"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://medium.com/@joongwon/java-java%EC%9D%98-generics-604b562530b3",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://medium.com/@joongwon/java-java의-generics-604b562530b3"),e("OutboundLink")],1)])])])},[],!1,null,null,null);a.default=r.exports}}]);