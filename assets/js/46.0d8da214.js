(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{340:function(e,t,r){"use strict";r.r(t);var s=r(1),v=Object(s.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"class"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class","aria-hidden":"true"}},[e._v("#")]),e._v(" Class")]),e._v(" "),r("h2",{attrs:{id:"immutable"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#immutable","aria-hidden":"true"}},[e._v("#")]),e._v(" Immutable")]),e._v(" "),r("p",[e._v("생성후 변경 불가능한 객체로서 대표적으로 "),r("em",[r("code",[e._v("String")])]),e._v(", "),r("em",[r("code",[e._v("Boolean")])]),e._v(", "),r("em",[r("code",[e._v("Integer")])]),e._v(", "),r("em",[r("code",[e._v("Float")])]),e._v(", "),r("em",[r("code",[e._v("Long")])]),e._v(" 등등이 있다.")]),e._v(" "),r("blockquote",[r("p",[e._v("HEAP 영역에서의 값이 바뀌는건 아니다.")])]),e._v(" "),r("p",[e._v("불편클래스의 예시는 아래가 대표적이다.")]),e._v(" "),r("h3",{attrs:{id:"string-stringbuffer-stringbuilder-의-사용"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string-stringbuffer-stringbuilder-의-사용","aria-hidden":"true"}},[e._v("#")]),e._v(" String / StringBuffer / StringBuilder 의 사용")]),e._v(" "),r("p",[e._v("문자열을 더하는 식에는 "),r("code",[e._v("string")]),e._v(" 보다는 "),r("code",[e._v("stringBuffer")]),e._v(" 나 "),r("code",[e._v("stringBuilder")]),e._v(" 을 사용해야 한다.")]),e._v(" "),r("p",[r("code",[e._v("string")]),e._v(" 은 새로운 값을 할당할 때마다 새로 생성되기 때문 (클래스의 메모리 참조 주소가 바뀜)")]),e._v(" "),r("p",[r("code",[e._v("stringBuffer")]),e._v(" 나 "),r("code",[e._v("stringBuilder")]),e._v(" 는 값을 메모리에 append 하는 방식으로 클래스를 별도로 생성하지 않는다.")]),e._v(" "),r("p",[r("code",[e._v("stringBuilder")]),e._v(" 는 변경 가능한 문자열로 synchronization 이 적용되지 않는다.")]),e._v(" "),r("p",[r("code",[e._v("stringBuffer")]),e._v(" 는 "),r("em",[r("strong",[e._v("멀티쓰레드 환경에서 안정적")])]),e._v(" 이다.")])])},[],!1,null,null,null);t.default=v.exports}}]);