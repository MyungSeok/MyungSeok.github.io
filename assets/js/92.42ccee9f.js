(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{437:function(t,e,n){"use strict";n.r(e);var r=n(1),i=Object(r.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"단일-책임의-원칙-srp-single-reponsiblity-principle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#단일-책임의-원칙-srp-single-reponsiblity-principle","aria-hidden":"true"}},[t._v("#")]),t._v(" 단일 책임의 원칙 (SRP : Single Reponsiblity Principle)")]),t._v(" "),n("p",[n("router-link",{attrs:{to:"/book/03.-back-end/01.-java/01.-general/solid/"}},[t._v("SOLID")]),t._v(" 원칙중에서 1번재 원칙으로 "),n("em",[n("strong",[t._v("단일 책임의 원칙")])]),t._v(" 이라 한다.")],1),t._v(" "),n("ul",[n("li",[t._v("소프트웨어의 설계 부품 (클래스, 함수) 는 단 하나의 책임 (기능) 만 가져야 한다.")])]),t._v(" "),n("p",[t._v("새로운 요구사항에 대해 프로그램이 영향 받는 부분이 적어야 한다. 다시 말하면 "),n("em",[n("strong",[t._v("응집도는 높고 결합도는 낮아야 한다")])]),t._v(" 라는 말이다."),n("br"),t._v("\n만약 한 프로그램이 책임(기능을 담당) 지고 있는 부분이 많아지면 클래스 내부의 함수끼리 강한 결합도를 가질수 있는 가능성이 높기 때문에 요구사항의 수정이 발생할 경우 유지보수 비용이 증가한다."),n("br"),t._v("\n따라서 책임 (기능) 을 분리 할 수 있는 구조로 설계되어야 한다.")])])},[],!1,null,null,null);e.default=i.exports}}]);