(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{316:function(a,t,r){"use strict";r.r(t);var e=r(1),v=Object(e.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"covariant-contravariant"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#covariant-contravariant","aria-hidden":"true"}},[a._v("#")]),a._v(" Covariant & Contravariant "),r("Badge",{attrs:{text:"Generic"}})],1),a._v(" "),r("h2",{attrs:{id:"공변-covariant"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#공변-covariant","aria-hidden":"true"}},[a._v("#")]),a._v(" 공변 (covariant)")]),a._v(" "),r("p",[r("em",[r("strong",[a._v("함께(共) 변한(變)다")])]),a._v(" 라는 뜻으로 "),r("code",[a._v("a")]),a._v(" 가 "),r("code",[a._v("A")]),a._v(" 의 하위 타입이라면 "),r("code",[a._v("a[]")]),a._v(" 는 "),r("code",[a._v("A[]")]),a._v(" 하위 타입이 된다.")]),a._v(" "),r("p",[r("em",[r("strong",[a._v("리스코프 치환 원칙")])]),a._v(" 이 적용된 사례로 자식 (파생) 클래스는 언제나 부모 (기반) 타입과 호환이 되어야 한다라는 특징이 있다. "),r("code",[a._v("<? extends T>")])]),a._v(" "),r("h2",{attrs:{id:"반공변-contravariant"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#반공변-contravariant","aria-hidden":"true"}},[a._v("#")]),a._v(" 반공변 (contravariant)")]),a._v(" "),r("p",[a._v("추상적인 방향으로 타입 변환을 허용 하는것 "),r("code",[a._v("<? super T>")])]),a._v(" "),r("h2",{attrs:{id:"무공변-불공변-invariant"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#무공변-불공변-invariant","aria-hidden":"true"}},[a._v("#")]),a._v(" 무공변 (불공변 : invariant)")]),a._v(" "),r("p",[a._v("오로지 자기 타입만 허용하는 것이다. "),r("code",[a._v("<T>")])]),a._v(" "),r("p",[a._v("제네릭 (매개변수화 타입 : Parameterized Types) 이 대표적이며 서로 다른 타입 "),r("code",[a._v("List<Type1>")]),a._v(" 은 "),r("code",[a._v("List<Type2>")]),a._v(" 의 상위타입도 하위타입도 아니다.")])])},[],!1,null,null,null);t.default=v.exports}}]);