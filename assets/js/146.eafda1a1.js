(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{346:function(a,t,s){"use strict";s.r(t);var n=s(0),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_1주차-1-4-chapter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1주차-1-4-chapter"}},[a._v("#")]),a._v(" 1주차 (1 ~ 4 Chapter)")]),a._v(" "),s("h2",{attrs:{id:"chapter-01-확장-가능한-언어"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-01-확장-가능한-언어"}},[a._v("#")]),a._v(" Chapter 01 확장 가능한 언어")]),a._v(" "),s("p",[a._v("스칼라(Scala) 라는 이름은 확장 가능한 언어(Scalable) 라는 뜻이다.\n이렇게 이름을 지은 이유는 스칼라를 사용자의 요구에 따라 자랄 수 있는 언어로 설계했기 때문이다.")]),a._v(" "),s("blockquote",[s("p",[s("code",[a._v("scalable")]),a._v(" 은 규모를 늘이고 줄이는게 자유롭다는 뜻이며, "),s("br"),a._v("보통 규모가 늘어나거나 줄어들어도 성능이나 비용이 선형적으로 증가한다는 뜻이다.")])]),a._v(" "),s("p",[a._v("스칼라는 객체지향 (Object Oriented) 과 함수형 (Functional) 프로그래밍 개념을 정적 타입 언어 (Statically Typed Language) 에 합쳐놓은 언어이다.")]),a._v(" "),s("h3",{attrs:{id:"_1-1-여러분의-마음에서-점점-자라나는-언어-a-language-that-grows-on-you"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-여러분의-마음에서-점점-자라나는-언어-a-language-that-grows-on-you"}},[a._v("#")]),a._v(" 1.1  여러분의 마음에서 점점 자라나는 언어 (a language that grows on you)")]),a._v(" "),s("div",{staticClass:"language-scala extra-class"},[s("pre",{pre:!0,attrs:{class:"language-scala"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" captial "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" Map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"US"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Washington"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"France"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(' "Paris'),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\ncapital "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Japan"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tokyo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nprintln"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("capital"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"France"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("위와 같이 높은 수준의 간결하고, 불필요한 세미콜론이나 타입 지정으로 인해 지저분하지 않게 코드 작성이 가능하다.")]),a._v(" "),s("p",[a._v("이들의 공통적인 특징은 "),s("strong",[a._v("연관맵")]),a._v("을 언어수준에서 지원한다는 점이다.")]),a._v(" "),s("h4",{attrs:{id:"새로운-타입을-키워가기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#새로운-타입을-키워가기"}},[a._v("#")]),a._v(" 새로운 타입을 키워가기")]),a._v(" "),s("p",[a._v("스칼라는 스칼라를 사용하는 사람들이 확장하고 변경할 수 있도록 설계했다. (Growing a language)")]),a._v(" "),s("div",{staticClass:"language-scala extra-class"},[s("pre",{pre:!0,attrs:{class:"language-scala"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("def")]),a._v(" factorial"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" BigInt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" BigInt "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" \n    x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" factorial"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[s("code",[a._v("factorial(30)")]),a._v(" 을 호출하면 다음과 같은 결과를 볼 수 있다.")]),a._v(" "),s("div",{staticClass:"language-scala extra-class"},[s("pre",{pre:!0,attrs:{class:"language-scala"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("265252859812191058636308480000000")]),a._v("\n")])])]),s("p",[a._v("반환 타입인 "),s("code",[a._v("BigInt")]),a._v(" 는 마치 내장 타입인것 처럼 보이지만 "),s("strong",[a._v("스칼라 표준 라이브러리에 들어있는 평범한 클래스")]),a._v("일 뿐이다.")]),a._v(" "),s("p",[a._v("예를 들어 Java 에서 지원하는 "),s("code",[a._v("BigInteger")]),a._v(" 를 사용한다면 다음과 같이 표현될 것 이다.")]),a._v(" "),s("div",{staticClass:"language-scala extra-class"},[s("pre",{pre:!0,attrs:{class:"language-scala"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("BigInteger\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("def")]),a._v(" factorial"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" BigInteger"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" BigInteger "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" BigInteger"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ZERO"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    BigInteger"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ONE\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v("\n    x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("multiply"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("factorial"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("subtract"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("BigInteger"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ONE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("위와 같은 코드는 내장타입이 그에 맞는 메서드나 기능을 제공해줘야 하기 때문에 다양한 환경에서 유연하게 적용하기 어려울 것이다.")]),a._v(" "),s("p",[a._v("가령 십진수, 복소수, 유리수, 신뢰구간, 다항식 등의 모든 기능을 하나의 언어에서 모든것을 제공하는 것은 확장성이 좋지 않다."),s("br"),a._v("\n스칼라는 언어가 기본적으로 지원하는것 처럼 사용자가 쉽게 사용할 수 있는 라이브러리를 제공하는 방식으로 사용자가 필요한 방향으로 확장하고 고칠 수 있게 허용한다.")]),a._v(" "),s("h3",{attrs:{id:"새로운-제어-구조-키워가기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#새로운-제어-구조-키워가기"}},[a._v("#")]),a._v(" 새로운 제어 구조 키워가기")]),a._v(" "),s("p",[a._v("스칼라의 확장성 원칙을 제어 구조에도 마찬가지로 적용된다.")]),a._v(" "),s("p",[a._v("이러한 확정성을 "),s("strong",[a._v("액터 기반 동시선 프로그래밍 (Actor-based concurrent programming)")]),a._v(" 스칼라 API 인 아카(Akka) 에서 볼 수 있다.")]),a._v(" "),s("p",[a._v("동시성 프로그래밍을 작성하는 일은 꽤 어려우며 자바의 스레드 모델은 공유 메모리 (Shared Memory) 와 락 (Lock) 기반으로 하며 코드를 보고 논리적으로 추론하기가 어렵다."),s("br"),a._v("코드에 숨어있는 경합 조건 (race condition) 이나 교착 상태 (deadlock) 이 없다고 확신하기는 어렵다.")]),a._v(" "),s("p",[a._v("안전한 대안은 얼랭 (Erlang) 프로그래밍에서 사용하는 "),s("strong",[a._v("액터")]),a._v(" 같은 메세지 전달 아키텍쳐이다.")])])}),[],!1,null,null,null);t.default=r.exports}}]);